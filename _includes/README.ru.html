<div class='toc'>
	<ol class='level-1'>
		<li><a href='#%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D1%8B'>Маршруты</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F'>Условия</a></li>
			<li><a href='#%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F'>Возвращаемые значения</a></li>
		</ol>
		<li><a href='#%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%84%D0%B0%D0%B9%D0%BB%D1%8B'>Статические файлы</a></li>
		<li><a href='#%D0%92%D0%B8%D0%B4%D1%8B%20/%20%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Виды / Шаблоны</a></li>
		<ol class='level-2'>
			<li><a href='#Haml%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Haml шаблоны</a></li>
			<li><a href='#Erb%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Erb шаблоны</a></li>
			<li><a href='#Erubis%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Erubis шаблоны</a></li>
			<li><a href='#Builder%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Builder шаблоны</a></li>
			<li><a href='#Nokogiri%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Nokogiri шаблоны</a></li>
			<li><a href='#Sass%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Sass шаблоны</a></li>
			<li><a href='#Scss%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Scss шаблоны</a></li>
			<li><a href='#Less%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Less шаблоны</a></li>
			<li><a href='#Liquid%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Liquid шаблоны</a></li>
			<li><a href='#Markdown%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Markdown шаблоны</a></li>
			<li><a href='#Textile%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Textile шаблоны</a></li>
			<li><a href='#RDoc%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>RDoc шаблоны</a></li>
			<li><a href='#Radius%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Radius шаблоны</a></li>
			<li><a href='#Markaby%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Markaby шаблоны</a></li>
			<li><a href='#Slim%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Slim шаблоны</a></li>
			<li><a href='#CoffeeScript%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>CoffeeScript шаблоны</a></li>
			<li><a href='#%D0%92%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Встроенные шаблоны</a></li>
			<li><a href='#%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%20%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B2%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0%D1%85'>Доступ к переменным в шаблонах</a></li>
			<li><a href='#%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Вложенные шаблоны</a></li>
			<li><a href='#%D0%98%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'>Именные шаблоны</a></li>
			<li><a href='#%D0%9F%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85%20%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B9'>Привязка файловых расширений</a></li>
			<li><a href='#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B0%20%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%D0%B0'>Добавление собственного движка рендеринга</a></li>
		</ol>
		<li><a href='#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%BD%D0%B8%D0%BA%D0%B8'>Методы-помощники</a></li>
		<li><a href='#%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B'>Фильтры</a></li>
		<li><a href='#%D0%9F%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>Прерывание</a></li>
		<li><a href='#%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0'>Передача</a></li>
		<li><a href='#%D0%94%D0%BE%D1%81%D0%BF%D1%83%D1%82%20%D0%BA%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%83%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0'>Доспут к объекту запроса</a></li>
		<li><a href='#%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F'>Конфигурация</a></li>
		<li><a href='#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA'>Обработка ошибок</a></li>
		<ol class='level-2'>
			<li><a href='#NotFound'>NotFound</a></li>
			<li><a href='#%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8'>Ошибки</a></li>
		</ol>
		<li><a href='#Mime-%D1%82%D0%B8%D0%BF%D1%8B'>Mime-типы</a></li>
		<li><a href='#Rack%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238220;'>Rack &#8220;прослойки&#8220;</a></li>
		<li><a href='#%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'>Тестирование</a></li>
		<li><a href='#Sinatra::Base%20%E2%80%94%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238221;,%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F'>Sinatra::Base — &#8220;прослойки&#8221;, библиотеки и модульные приложения</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9'>Запуск модульных приложений</a></li>
			<li><a href='#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20&%238220;%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85&%238221;%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%81%20config.ru'>Запуск &#8220;классических&#8221; приложений с config.ru</a></li>
			<li><a href='#%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20config.ru?'>Когда использовать config.ru?</a></li>
			<li><a href='#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20Sinatra%20%D0%B2%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238220;'>Использование Sinatra в качестве &#8220;прослойки&#8220;</a></li>
		</ol>
		<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0'>Области видимости и привязка</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20/%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0'>Область видимости приложения / класса</a></li>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0/%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0'>Область видимости запроса/экземпляра</a></li>
			<li><a href='#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F'>Область видимости делегирования</a></li>
		</ol>
		<li><a href='#%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0'>Командная строка</a></li>
		<li><a href='#%D0%9D%D0%B0%20%D0%BE%D1%81%D1%82%D1%80%D0%B8%D0%B5'>На острие</a></li>
		<ol class='level-2'>
			<li><a href='#%D0%A1%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20Bundler'>С помощью Bundler</a></li>
			<li><a href='#%D0%92%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E'>Вручную</a></li>
			<li><a href='#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE'>Установка глобально</a></li>
		</ol>
		<li><a href='#%D0%94%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B5%D0%B5%20%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5'>Дальнейшее чтение</a></li>
	</ol>
</div>

<p>
<em>Внимание: Этот документ является переводом <a href="http://sinatrarb.com/intro">Английской версии</a> и может
быть устаревшим</em>
</p>
<p>
Sinatra — это предметно-ориентированный язык (DSL) для быстрого создания
приложений на Ruby с приложением минимума усилий:
</p>
<pre>
  # myapp.rb
  require 'sinatra'
  
  get '/' do
    'Hello world!'
  end
</pre>
<p>
Установите gem и запустите приложение с помощью:
</p>
<pre>
  gem install sinatra
  ruby -rubygems myapp.rb
</pre>
<p>
Результат будет тут: <a href="http://localhost:4567">localhost:4567</a>
</p>
<a name='%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D1%8B'></a>
<h2>Маршруты</h2>
<p>
В Sinatra маршрут — это пара: HTTP метод и шаблон (образец) URL. Каждый
маршрут ассоциирован с блоком:
</p>
<pre>
  get '/' do
    .. что-то показать ..
  end

  post '/' do
    .. что-то создать ..
  end

  put '/' do
    .. что-то обновить ..
  end

  delete '/' do
    .. что-то удалить ..
  end

  options '/' do
    .. что-то ответить ..
  end
</pre>
<p>
Маршруты сверяются с запросом по очередности определения. Первый же
совпавший с запросом маршрут и будет вызван.
</p>
<p>
Шаблоны маршрутов могут включать в себя параметры доступные в
<tt>params</tt> xэше:
</p>
<pre>
  get '/hello/:name' do
    # соответствует &quot;GET /hello/foo&quot; и &quot;GET /hello/bar&quot;,
    # где params[:name] 'foo' или 'bar'
    &quot;Hello #{params[:name]}!&quot;
  end
</pre>
<p>
Можно также использовать именные параметры в переменных блоков:
</p>
<pre>
  get '/hello/:name' do |n|
    &quot;Hello #{n}!&quot;
  end
</pre>
<p>
Шаблоны маршрутов также могут включать splat (wildcard, *, любая строка
символов) параметры доступные в <tt>params[:splat]</tt> массиве.
</p>
<pre>
  get '/say/*/to/*' do
    # соответствует /say/hello/to/world
    params[:splat] # =&gt; [&quot;hello&quot;, &quot;world&quot;]
  end

  get '/download/*.*' do
    # соответствует /download/path/to/file.xml
    params[:splat] # =&gt; [&quot;path/to/file&quot;, &quot;xml&quot;]
  end
</pre>
<p>
Маршруты также могут использовать регулярные выражения в качестве шаблона
URL:
</p>
<pre>
  get %r{/hello/([\w]+)} do
    &quot;Hello, #{params[:captures].first}!&quot;
  end
</pre>
<p>
Или с параметром блока:
</p>
<pre>
  get %r{/hello/([\w]+)} do |c|
    &quot;Hello, #{c}!&quot;
  end
</pre>
<a name='%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F'></a>
<h3>Условия</h3>
<p>
Маршруты могут включать различные условия совпадений, такие как user agent:
</p>
<pre>
  get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
    &quot;You're using Songbird version #{params[:agent][0]}&quot;
  end

  get '/foo' do
    # соответствует non-songbird браузерам
  end
</pre>
<p>
Другими доступными условиями являются <tt>host_name</tt> и
<tt>provides</tt>:
</p>
<pre>
  get '/', :host_name =&gt; /^admin\./ do
    &quot;Admin Area, Access denied!&quot;
  end

  get '/', :provides =&gt; 'html' do
    haml :index
  end
  
  get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
    builder :feed
  end
</pre>
<p>
Довольно легко можно задать собственные условия:
</p>
<pre>
  set(:probability) { |value| condition { rand &lt;= value } }
  
  get '/win_a_car', :probability =&gt; 0.1 do
    &quot;You won!&quot;
  end
  
  get '/win_a_car' do
    &quot;Sorry, you lost.&quot;
  end
</pre>
<a name='%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F'></a>
<h3>Возвращаемые значения</h3>
<p>
Возвращаемое значение блока маршрута ограничивается телом ответа, которое
будет передано HTTP клиенту, или следующей &#8220;прослойкой&#8221;
(middleware, промежуточная программа) в Rack стеке. Чаще всего это строка,
как в вышеизложенных примерах. Но и другие значения также приемлемы.
</p>
<p>
Вы можете вернуть любой объект, который будет либо корректным Rack ответом,
Rack телом ответа, либо кодом состояния HTTP:
</p>
<ul>
<li><p>
Массив с тремя переменными: <tt>[status (Fixnum), headers (Hash), response
body (должен отвечать на #each)]</tt>
</p>
</li>
<li><p>
Массив с двумя переменными: <tt>[status (Fixnum), response body (должен
отвечать на #each)]</tt>
</p>
</li>
<li><p>
Объект, отвечающий на <tt>#each</tt>, который передает только строковые
типы данных в этот блок
</p>
</li>
<li><p>
Fixnum, соответствующий коду состояния HTTP
</p>
</li>
</ul>
<p>
Таким образом мы легко можем создать поточный пример:
</p>
<pre>
    class Stream
      def each
        100.times { |i| yield &quot;#{i}\n&quot; }
      end
    end

    get('/') { Stream.new }
</pre>
<a name='%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%84%D0%B0%D0%B9%D0%BB%D1%8B'></a>
<h2>Статические файлы</h2>
<p>
Статические файлы отдаются из <tt>./public</tt> директории. Вы можете
указать другое место, используя <tt>:public</tt> опцию:
</p>
<pre>
  set :public, File.dirname(__FILE__) + '/static'
</pre>
<p>
Учтите, что имя директории со статическими файлами не включено в URL.
Например, файл <tt>./public/css/style.css</tt> будет доступен как <tt><a
href="http://example.com/css/style.css">example.com/css/style.css</a></tt>.
</p>
<a name='%D0%92%D0%B8%D0%B4%D1%8B%20/%20%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h2>Виды / Шаблоны</h2>
<p>
Шаблоны по умолчанию будут использованы из директории <tt>./views</tt>. Для
использования другой директории:
</p>
<pre>
  set :views, File.dirname(__FILE__) + '/templates'
</pre>
<p>
Важно помнить, что вы всегда должны указывать шаблоны с помощью символов,
даже если это подкаталог (в этом случае используйте
<tt>:'subdir/template'</tt>). Вы должны использовать символ, иначе методы,
ответственные за рендеринг, отобразят просто переданную им строку.
</p>
<a name='Haml%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Haml шаблоны</h3>
<p>
<tt>haml</tt> gem/библиотека необходима для рендеринга HAML шаблонов:
</p>
<pre>
  # Вам нужно будет подключить haml gem в приложении
  require 'haml'

  get '/' do
    haml :index
  end
</pre>
<p>
Отрисует <tt>./views/index.haml</tt>.
</p>
<p>
<a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Опции
Haml</a> могут быть установлены глобально через конфигурацию Sinatra, см.
<a href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены локально.
</p>
<pre>
  set :haml, :format =&gt; :html5 # :xhtml - Haml формат по умолчанию

  get '/' do
    haml :index, :format =&gt; :html4 # переопределен
  end
</pre>
<a name='Erb%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Erb шаблоны</h3>
<pre>
  # Вам нужно будет подключить erb в приложении
  require 'erb'

  get '/' do
    erb :index
  end
</pre>
<p>
Отрисует <tt>./views/index.erb</tt>.
</p>
<a name='Erubis%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Erubis шаблоны</h3>
<p>
<tt>erubis</tt> gem/библиотека необходима для рендеринга Erubis шаблонов:
</p>
<pre>
  # Вам нужно будет подключить Erubis в приложении
  require 'erubis'

  get '/' do
    erubis :index
  end
</pre>
<p>
Отрисует <tt>./views/index.erubis</tt>.
</p>
<p>
Также возможно заменить Erb на Erubis:
</p>
<pre>
  require 'erubis'
  Tilt.register :erb, Tilt[:erubis]

  get '/' do
    erb :index
  end
</pre>
<p>
Отрисует <tt>./views/index.erb</tt> с помощью Erubis.
</p>
<a name='Builder%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Builder шаблоны</h3>
<p>
<tt>builder</tt> gem/библиотека необходима для рендеринга builder шаблонов:
</p>
<pre>
  # Вам нужно будет подключить builder в приложении
  require 'builder'

  get '/' do
    builder :index
  end
</pre>
<p>
Отрисует <tt>./views/index.builder</tt>.
</p>
<a name='Nokogiri%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Nokogiri шаблоны</h3>
<p>
<tt>nokogiri</tt> gem/библиотека необходима для рендеринга nokogiri
шаблонов:
</p>
<pre>
  # Вам нужно будет подключить nokogiri в приложении
  require 'nokogiri'

  get '/' do
    nokogiri :index
  end
</pre>
<p>
Отрисует <tt>./views/index.nokogiri</tt>.
</p>
<a name='Sass%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Sass шаблоны</h3>
<p>
<tt>haml</tt> gem/библиотека необходима для рендеринга Sass шаблонов:
</p>
<pre>
  # Вам нужно будет подключить haml или sass в приложении
  require 'sass'

  get '/stylesheet.css' do
    sass :stylesheet
  end
</pre>
<p>
Отрисует <tt>./views/stylesheet.sass</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Опции
Sass</a> могут быть установлены глобально через конфигурацию Sinatra, см.
<a href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены локально.
</p>
<pre>
  set :sass, :style =&gt; :compact # :nested - стиль Sass по умолчанию

  get '/stylesheet.css' do
    sass :stylesheet, :style =&gt; :expanded # переопределен
  end
</pre>
<a name='Scss%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Scss шаблоны</h3>
<p>
<tt>haml</tt> gem/библиотека необходима для рендеринга Scss шаблонов:
</p>
<pre>
  # Вам нужно будет подключить haml или sass в приложении
  require 'sass'

  get '/stylesheet.css' do
    scss :stylesheet
  end
</pre>
<p>
Отрисует <tt>./views/stylesheet.scss</tt>.
</p>
<p>
<a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Опции
Scss</a> могут быть установлены глобально через конфигурацию Sinatra, см.
<a href="http://www.sinatrarb.com/configuration.html">Опции и
Конфигурация</a>, и переопределены локально.
</p>
<pre>
  set :scss, :style =&gt; :compact # :nested - стиль Scss по умолчанию

  get '/stylesheet.css' do
    scss :stylesheet, :style =&gt; :expanded # переопределен
  end
</pre>
<a name='Less%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Less шаблоны</h3>
<p>
<tt>less</tt> gem/библиотека необходима для рендеринга Less шаблонов:
</p>
<pre>
  # Вам нужно будет подключить less в приложении
  require 'less'

  get '/stylesheet.css' do
    less :stylesheet
  end
</pre>
<p>
Отрисует <tt>./views/stylesheet.less</tt>.
</p>
<a name='Liquid%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Liquid шаблоны</h3>
<p>
<tt>liquid</tt> gem/библиотека необходима для рендеринга liquid шаблонов:
</p>
<pre>
  # Вам нужно будет подключить liquid в приложении
  require 'liquid'

  get '/' do
    liquid :index
  end
</pre>
<p>
Отрисует <tt>./views/index.liquid</tt>.
</p>
<p>
Так как в Liquid шаблонах невозможно вызывать методы из Ruby (кроме
<tt>yield</tt>), то вы почти всегда будете передавать локальные переменные:
</p>
<pre>
  liquid :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Markdown%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Markdown шаблоны</h3>
<p>
<tt>rdiscount</tt> gem/библиотека необходима для рендеринга Markdown
шаблонов:
</p>
<pre>
  # Вам нужно будет подключить rdiscount в приложении
  require &quot;rdiscount&quot;
  
  get '/' do
    markdown :index
  end
</pre>
<p>
Отрисует <tt>./views/index.markdown</tt> (<tt>md</tt> и <tt>mkd</tt> также
являются допустимыми файловыми расширениями).
</p>
<p>
В Markdown невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон
совместно с другим движком рендеринга:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</pre>
<p>
Заметьте, что вы можете вызывать метод <tt>markdown</tt> из других
шаблонов:
</p>
<pre>
  %h1 Hello From Haml!
  %p= markdown(:greetings)
</pre>
<p>
Вы не можете вызывать Ruby из Markdown, соответственно, вы не можете
использовать лэйаут-шаблоны (layouts) на Markdown. Тем не менее, есть
возможность использовать один движок рендеринга для шаблона, а другой для
лэйаута с помощью опции `:layout_engine`:
</p>
<pre>
  get '/' do
    markdown :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Отрисует <tt>./views/index.md</tt> с <tt>./views/layout.erb</tt> в качестве
лэйаута.
</p>
<p>
Также вы можете задать такие опции рендеринга глобально:
</p>
<pre>
  set :markdown, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    markdown :index
  end
</pre>
<p>
Отрисует <tt>./views/index.md</tt> (и любой другой шаблон на Markdown) с
<tt>./views/post.haml</tt> в качестве лэйаута.
</p>
<p>
Также возможно обрабатывать Markdown с помощью BlueCloth, а не RDiscount:
</p>
<pre>
  require 'bluecloth'

  Tilt.register 'markdown', BlueClothTemplate
  Tilt.register 'mkd',      BlueClothTemplate
  Tilt.register 'md',       BlueClothTemplate

  get '/' do
    markdown :index
  end
</pre>
<p>
Отрисует <tt>./views/index.md</tt> с помощью BlueCloth.
</p>
<a name='Textile%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Textile шаблоны</h3>
<p>
<tt>RedCloth</tt> gem/библиотека необходима для рендеринга Textile
шаблонов:
</p>
<pre>
  # Вам нужно будет подключить redcloth в приложении
  require &quot;redcloth&quot;

  get '/' do
    textile :index
  end
</pre>
<p>
Отрисует <tt>./views/index.textile</tt>.
</p>
<p>
В Textile невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон
совместно с другим движком рендеринга:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }
</pre>
<p>
Заметьте, что вы можете вызывать метод <tt>textile</tt> из других шаблонов:
</p>
<pre>
  %h1 Hello From Haml!
  %p= textile(:greetings)
</pre>
<p>
Вы не можете вызывать Ruby из Textile, соответственно, вы не можете
использовать лэйаут-шаблоны на Textile. Тем не менее, есть возможность
использовать один движок рендеринга для шаблона, а другой для лэйаута с
помощью опции `:layout_engine`:
</p>
<pre>
  get '/' do
    textile :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Отрисует <tt>./views/index.textile</tt> с <tt>./views/layout.erb</tt> в
качестве лэйаута.
</p>
<p>
Также вы можете задать такие опции рендеринга глобально:
</p>
<pre>
  set :textile, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    textile :index
  end
</pre>
<p>
Отрисует <tt>./views/index.textile</tt> (и любой другой шаблон на Textile)
с <tt>./views/post.haml</tt> в качестве лэйаута.
</p>
<a name='RDoc%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>RDoc шаблоны</h3>
<p>
<tt>rdoc</tt> gem/библиотека необходима для рендеринга RDoc шаблонов:
</p>
<pre>
  # Вам нужно будет подключить rdoc/markup/to_html в приложении
  require &quot;rdoc/markup/to_html&quot;

  get '/' do
    rdoc :index
  end
</pre>
<p>
Отрисует <tt>./views/index.rdoc</tt>.
</p>
<p>
В RDoc невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон
совместно с другим движком рендеринга:
</p>
<pre>
  erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
</pre>
<p>
Заметьте, что вы можете вызывать метод <tt>rdoc</tt> из других шаблонов:
</p>
<pre>
  %h1 Hello From Haml!
  %p= rdoc(:greetings)
</pre>
<p>
Вы не можете вызывать Ruby из RDoc, соответственно, вы не можете
использовать лэйаут-шаблоны на RDoc. Тем не менее, есть возможность
использовать один движок рендеринга для шаблона, а другой для лэйаута с
помощью опции `:layout_engine`:
</p>
<pre>
  get '/' do
    rdoc :index, :layout_engine =&gt; :erb
  end
</pre>
<p>
Отрисует <tt>./views/index.rdoc</tt> с <tt>./views/layout.erb</tt> в
качестве лэйаута.
</p>
<p>
Также вы можете задать такие опции рендеринга глобально:
</p>
<pre>
  set :rdoc, :layout_engine =&gt; :haml, :layout =&gt; :post

  get '/' do
    rdoc :index
  end
</pre>
<p>
Отрисует <tt>./views/index.rdoc</tt> (и любой другой шаблон на RDoc) с
<tt>./views/post.haml</tt> в качестве лэйаута.
</p>
<a name='Radius%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Radius шаблоны</h3>
<p>
<tt>radius</tt> gem/библиотека необходима для рендеринга Radius шаблонов:
</p>
<pre>
  # Вам нужно будет подключить radius в приложении
  require 'radius'

  get '/' do
    radius :index
  end
</pre>
<p>
Отрисует <tt>./views/index.radius</tt>.
</p>
<p>
Так как в Radius шаблоне невозможно вызывать методы из Ruby (кроме
<tt>yield</tt>),  то вы почти всегда будете передавать локальные
переменные:
</p>
<pre>
  radius :index, :locals =&gt; { :key =&gt; 'value' }
</pre>
<a name='Markaby%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Markaby шаблоны</h3>
<p>
<tt>markaby</tt> gem/библиотека необходима для рендеринга Markaby шаблонов:
</p>
<pre>
  # Вам нужно будет подключить markaby в приложении
  require 'markaby'

  get '/' do
    markaby :index
  end
</pre>
<p>
Отрисует <tt>./views/index.mab</tt>.
</p>
<p>
Вы также можете использовать внутристроковые Markaby шаблоны:
</p>
<pre>
  get '/' do
    markaby { h1 &quot;Welcome!&quot; }
  end
</pre>
<a name='Slim%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Slim шаблоны</h3>
<p>
<tt>slim</tt> gem/библиотека необходима для рендеринга slim шаблонов:
</p>
<pre>
  # Вам нужно будет подключить slim в приложении
  require 'slim'

  get '/' do
    slim :index
  end
</pre>
<p>
Отрисует <tt>./views/index.slim</tt>.
</p>
<a name='CoffeeScript%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>CoffeeScript шаблоны</h3>
<p>
Вам понадобится <tt>coffee-script</tt> gem/библиотека и что-то <b>одно</b>
из следующего списка, чтобы запускать JavaScript:
</p>
<ul>
<li><p>
<tt>node</tt> (из Node.js)
</p>
</li>
<li><p>
вы можете использовать OSX (есть встроенные средства для выполнения
JavaScript)
</p>
</li>
<li><p>
<tt>therubyracer</tt> gem/библиотека
</p>
</li>
</ul>
<p>
Подробнее смотрите на <a
href="http://github.com/josh/ruby-coffee-script">странице проекта</a>.
</p>
<p>
Таким образом вы можете использовать CoffeeScript шаблоны.
</p>
<pre>
  # Вам нужно будет подключить coffee-script в приложении
  require 'coffee-script'

  get '/application.js' do
    coffee :application
  end
</pre>
<p>
Отрисует <tt>./views/application.coffee</tt>.
</p>
<a name='%D0%92%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Встроенные шаблоны</h3>
<pre>
  get '/' do
    haml '%div.title Hello World'
  end
</pre>
<p>
Отрисует встроенный (строчный) шаблон.
</p>
<a name='%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%20%D0%BA%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%20%D0%B2%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0%D1%85'></a>
<h3>Доступ к переменным в шаблонах</h3>
<p>
Шаблоны интерпретируются в том же контексте, что и обработчики маршрутов.
Переменные экземпляра, установленные в процессе обработки маршрутов, будут
доступны напрямую в шаблонах:
</p>
<pre>
  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.name'
  end
</pre>
<p>
Либо установите их через хеш локальных переменных:
</p>
<pre>
  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
  end
</pre>
<p>
Это обычный подход, когда шаблоны рендерятся как частные (partials) из
других шаблонов.
</p>
<a name='%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Вложенные шаблоны</h3>
<p>
Шаблоны также могут быть определены в конце файла-исходника:
</p>
<pre>
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Hello world!!!!!
</pre>
<p>
Заметьте: Вложенные шаблоны, определенные в файле-исходнике, который
подключил Sinatra, будут автоматически загружены. Вызовите <tt>enable
:inline_templates</tt> напрямую, если у вас вложенные шаблоны в других
файлах.
</p>
<a name='%D0%98%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B'></a>
<h3>Именные шаблоны</h3>
<p>
Шаблоны также могут быть определены, используя <tt>template</tt> метод:
</p>
<pre>
  template :layout do
    &quot;%html\n  =yield\n&quot;
  end

  template :index do
    '%div.title Hello World!'
  end

  get '/' do
    haml :index
  end
</pre>
<p>
Если шаблон с именем &#8220;layout&#8221; существует, то он будет
использован каждый раз, когда шаблоны будут отрисовываться. Вы можете
отключать лэйаут в каждом конкретном случае с помощью <tt>:layout =&gt;
false</tt> или отключить его для всего приложения, например, так: <tt>set
:haml, :layout =&gt; false</tt>.
</p>
<pre>
  get '/' do
    haml :index, :layout =&gt; !request.xhr?
  end
</pre>
<a name='%D0%9F%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85%20%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B9'></a>
<h3>Привязка файловых расширений</h3>
<p>
Чтобы связать расширение файла и движок рендеринга, используйте
<tt>Tilt.register</tt>. Например, если вы хотите использовать расширение
<tt>tt</tt> для шаблонов Textile:
</p>
<pre>
  Tilt.register :tt, Tilt[:textile]
</pre>
<a name='%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B0%20%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3%D0%B0'></a>
<h3>Добавление собственного движка рендеринга</h3>
<p>
Сначала зарегистрируйте свой движок в Tilt, затем создайте метод,
отвечающий за отрисовку:
</p>
<pre>
  Tilt.register :myat, MyAwesomeTemplateEngine

  helpers do
    def myat(*args) render(:myat, *args) end
  end

  get '/' do
    myat :index
  end
</pre>
<p>
Отрисует <tt>./views/index.myat</tt>. Чтобы узнать больше о Tilt, смотрите
<a href="https://github.com/rtomayko/tilt">github.com/rtomayko/tilt</a>
</p>
<a name='%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%BD%D0%B8%D0%BA%D0%B8'></a>
<h2>Методы-помощники</h2>
<p>
Используйте метод <tt>helpers</tt>, чтобы определить методы-помощники,
которые в дальнейшем можно будет использовать в обработчиках маршрутов и
шаблонах:
</p>
<pre>
  helpers do
    def bar(name)
      &quot;#{name}bar&quot;
    end
  end

  get '/:name' do
    bar(params[:name])
  end
</pre>
<a name='%D0%A4%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D1%8B'></a>
<h2>Фильтры</h2>
<p>
Before-фильтры выполняются перед каждым запросом в том же контексте, что и
маршруты. Фильтры могут изменять как запрос, так и ответ на него.
Переменные экземпляра, установленные в фильтрах, доступны в маршрутах и
шаблонах:
</p>
<pre>
  before do
    @note = 'Hi!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=&gt; 'Hi!'
    params[:splat] #=&gt; 'bar/baz'
  end
</pre>
<p>
After-фильтры выполняются после каждого запроса в том же контексте, что и
пути. Фильтры могут изменять как запрос, так и ответ на него. Переменные
экземпляра, установленные в before-фильтрах и маршрутах, будут доступны в
after-фильтрах:
</p>
<pre>
  after do
    puts response.status
  end
</pre>
<p>
Фильтры могут использовать шаблоны URL и будут интерпретированы, только
если путь запроса совпадет с этим шаблоном:
</p>
<pre>
  before '/protected/*' do
    authenticate!
  end

  after '/create/:slug' do |slug|
    session[:last_slug] = slug
  end
</pre>
<p>
Как и маршруты, фильтры могут использовать условия:
</p>
<pre>
  before :agent =&gt; /Songbird/ do
    # ...
  end

  after '/blog/*', :host_name =&gt; 'example.com' do
    # ...
  end
</pre>
<a name='%D0%9F%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'></a>
<h2>Прерывание</h2>
<p>
Чтобы незамедлительно прервать обработку запроса внутри фильтра или
маршрута, используйте:
</p>
<pre>
  halt
</pre>
<p>
Можно также указать статус при прерывании:
</p>
<pre>
  halt 410
</pre>
<p>
Тело:
</p>
<pre>
  halt 'this will be the body'
</pre>
<p>
И то, и другое:
</p>
<pre>
  halt 401, 'go away!'
</pre>
<p>
Можно указать заголовки:
</p>
<pre>
  halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revenge'
</pre>
<a name='%D0%9F%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0'></a>
<h2>Передача</h2>
<p>
Маршрут может передать обработку запроса следующему совпадающему маршруту,
используя <tt>pass</tt>:
</p>
<pre>
  get '/guess/:who' do
    pass unless params[:who] == 'Frank'
    'You got me!'
  end

  get '/guess/*' do
    'You missed!'
  end
</pre>
<p>
Блок маршрута сразу же прерывается, и контроль переходит к следующему
совпадающему маршруту. Если соответствующий маршрут не найден, то ответом
на запрос будет 404.
</p>
<a name='%D0%94%D0%BE%D1%81%D0%BF%D1%83%D1%82%20%D0%BA%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%83%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0'></a>
<h2>Доспут к объекту запроса</h2>
<p>
Объект входящего запроса доступен на уровне обработки запроса (в фильтрах,
маршрутах, обработчиках ошибок) с помощью `request` метода:
</p>
<pre>
  # приложение запущено на http://example.com/example
  get '/foo' do
    request.body              # тело запроса, посланное клиентом (см. ниже)
    request.scheme            # &quot;http&quot;
    request.script_name       # &quot;/example&quot;
    request.path_info         # &quot;/foo&quot;
    request.port              # 80
    request.request_method    # &quot;GET&quot;
    request.query_string      # &quot;&quot;
    request.content_length    # длина тела запроса
    request.media_type        # медиатип тела запроса
    request.host              # &quot;example.com&quot;
    request.get?              # true (есть аналоги для других методов HTTP)
    request.form_data?        # false
    request[&quot;SOME_HEADER&quot;]    # значение заголовка SOME_HEADER
    request.referer           # источник запроса клиента либо '/'
    request.user_agent        # user agent (используется для :agent условия)
    request.cookies           # хеш с куками браузера
    request.xhr?              # является ли запрос ajax запросом?
    request.url               # &quot;http://example.com/example/foo&quot;
    request.path              # &quot;/example/foo&quot;
    request.ip                # IP-адрес клиента
    request.secure?           # false
    request.env               # &quot;сырой&quot; env хеш, полученный Rack
  end
</pre>
<p>
Некоторые опции, такие как <tt>script_name</tt> или <tt>path_info</tt>
доступны для записи:
</p>
<pre>
  before { request.path_info = &quot;/&quot; }
  
  get &quot;/&quot; do
    &quot;all requests end up here&quot;
  end
</pre>
<p>
<tt>request.body</tt> является IO или StringIO объектом:
</p>
<pre>
  post &quot;/api&quot; do
    request.body.rewind  # в случае, если кто-то уже прочитал тело запроса
    data = JSON.parse request.body.read
    &quot;Hello #{data['name']}!&quot;
  end
</pre>
<a name='%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F'></a>
<h2>Конфигурация</h2>
<p>
Этот блок исполняется один раз при старте в любом окружении, режиме
(environment):
</p>
<pre>
  configure do
    ...
  end
</pre>
<p>
Будет запущено, когда окружение (RACK_ENV переменная) установлена в
<tt>:production</tt>:
</p>
<pre>
  configure :production do
    ...
  end
</pre>
<p>
Будет запущено, когда окружение <tt>:production</tt> или <tt>:test</tt>:
</p>
<pre>
  configure :production, :test do
    ...
  end
</pre>
<a name='%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA'></a>
<h2>Обработка ошибок</h2>
<p>
Обработчики ошибок исполняются в том же контексте, что и маршруты,
before-фильтры, а это означает, что всякие прелести вроде <tt>haml</tt>,
<tt>erb</tt>, <tt>halt</tt> и т.д. доступны и им.
</p>
<a name='NotFound'></a>
<h3>NotFound</h3>
<p>
Когда возбуждено исключение <tt>Sinatra::NotFound</tt>, или кодом ответа
является 404, то будет вызван <tt>not_found</tt> обработчик:
</p>
<pre>
  not_found do
    'This is nowhere to be found.'
  end
</pre>
<a name='%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8'></a>
<h3>Ошибки</h3>
<p>
Обработчик ошибок <tt>error</tt> будет вызван, когда исключение возбуждено
из блока маршрута, либо из фильтра. Объект-исключение доступен как
переменная <tt>sinatra.error</tt> в Rack:
</p>
<pre>
  error do
    'Sorry there was a nasty error - ' + env['sinatra.error'].name
  end
</pre>
<p>
Частные ошибки:
</p>
<pre>
  error MyCustomError do
    'So what happened was...' + request.env['sinatra.error'].message
  end
</pre>
<p>
Тогда, если это произошло:
</p>
<pre>
  get '/' do
    raise MyCustomError, 'something bad'
  end
</pre>
<p>
То вы получите:
</p>
<pre>
  So what happened was... something bad
</pre>
<p>
Также вы можете установить обработчик ошибок для кода состояния HTTP:
</p>
<pre>
  error 403 do
    'Access forbidden'
  end

  get '/secret' do
    403
  end
</pre>
<p>
Либо набора кодов:
</p>
<pre>
  error 400..510 do
    'Boom'
  end
</pre>
<p>
Sinatra устанавливает специальные <tt>not_found</tt> и <tt>error</tt>
обработчики, когда запущена в режиме разработки (окружение
<tt>:development</tt>).
</p>
<a name='Mime-%D1%82%D0%B8%D0%BF%D1%8B'></a>
<h2>Mime-типы</h2>
<p>
Когда вы используете <tt>send_file</tt> или статические файлы, у вас могут
быть mime-типы, которые Sinatra не понимает по умолчанию. Используйте
<tt>mime_type</tt> для их регистрации по расширению файла:
</p>
<pre>
  mime_type :foo, 'text/foo'
</pre>
<p>
Вы также можете использовать это в <tt>content_type</tt> помощнике:
</p>
<pre>
  content_type :foo
</pre>
<a name='Rack%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238220;'></a>
<h2>Rack &#8220;прослойки&#8220;</h2>
<p>
Sinatra использует <a href="http://rack.rubyforge.org/">Rack</a>,
минимальный стандартный  интерфейс для веб-фреймворков на Ruby. Одной из
самых интересных для разработчиков возможностей Rack является поддержка
&#8220;прослоек&#8221; (&#8220;middleware&#8221;) — компонентов,
&#8220;сидящих&#8221; между сервером и вашим приложением, которые
отслеживают и/или манипулируют HTTP запросами/ответами для предоставления
различной функциональности.
</p>
<p>
В Sinatra очень просто использовать такие &#8220;прослойки&#8221; с помощью
метода <tt>use</tt>:
</p>
<pre>
  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/hello' do
    'Hello World'
  end
</pre>
<p>
Семантика <tt>use</tt> идентична той, что определена для <a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
DSL (чаще всего используется в rackup файлах). Например, <tt>use</tt> метод
принимает множественные переменные, также как и блоки:
</p>
<pre>
  use Rack::Auth::Basic do |username, password|
    username == 'admin' &amp;&amp; password == 'secret'
  end
</pre>
<p>
Rack распространяется с различными стандартными &#8220;прослойками&#8221;
для логирования, отладки, маршрутизации URL, аутентификации, обработки
сессий. Sinatra использует многие из этих компонентов автоматически,
основываясь на конфигурации, чтобы вам не приходилось
регистрировать/использовать (<tt>use</tt>) их вручную.
</p>
<a name='%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5'></a>
<h2>Тестирование</h2>
<p>
Тесты для Sinatra приложений могут быть написаны с помощью библиотек,
фреймворков, поддерживающих тестирование Rack. <a
href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> рекомендован:
</p>
<pre>
  require 'my_sinatra_app'
  require 'test/unit'
  require 'rack/test'

  class MyAppTest &lt; Test::Unit::TestCase
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Hello World!', last_response.body
    end

    def test_with_params
      get '/meet', :name =&gt; 'Frank'
      assert_equal 'Hello Frank!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
      assert_equal &quot;You're using Songbird!&quot;, last_response.body
    end
  end
</pre>
<p>
Обратите внимание: Встроенные модуль Sinatra::Test и класс
Sinatra::TestHarness являются устаревшими, начиная с релиза 0.9.2.
</p>
<a name='Sinatra::Base%20%E2%80%94%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238221;,%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F'></a>
<h2>Sinatra::Base — &#8220;прослойки&#8221;, библиотеки и модульные приложения</h2>
<p>
Описание своего приложения самым простейшим способом (с помощью DSL
верхнего уровня, как в примерах выше) работает отлично для крохотных
приложений, но имеет множество недостатков, когда надо создать компоненты,
такие как Rack middleware (&#8220;прослойки&#8221;), Rails metal, простые
библиотеки с серверными компонентами, расширения Sinatra. DSL верхнего
уровня загрязняет пространство имен <tt>Object</tt> и подразумевает стиль
конфигурации микро-приложения (например, единый файл приложения, ./public и
./views директории, создание логов, страницу деталей об исключениях  и
т.д.). И тут на помощь приходит Sinatra::Base:
</p>
<pre>
  require 'sinatra/base'

  class MyApp &lt; Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Hello world!'
    end
  end
</pre>
<p>
Методы, доступные Sinatra::Base сабклассам идентичны тем, что доступны в
DSL верхнего уровня. Большинство приложений верхнего уровня могут быть
конвертированы в Sinatra::Base компоненты с помощью двух модификаций:
</p>
<ul>
<li><p>
Вы должны подключать <tt>sinatra/base</tt> вместо <tt>sinatra</tt>, иначе
все методы предоставляемые Sinatra будут импортированные в глобальное
пространство имен.
</p>
</li>
<li><p>
Поместите все маршруты, обработчики ошибок, фильтры и опции в сабкласс
Sinatra::Base.
</p>
</li>
</ul>
<p>
<tt>Sinatra::Base</tt> — это чистый лист. Большинство опций, включая
встроенный сервер, по умолчанию отключены. Смотрите <a
href="http://www.sinatrarb.com/configuration.html">Опции и Конфигурация</a>
для детальной информации об опциях и их поведении.
</p>
<a name='%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9'></a>
<h3>Запуск модульных приложений</h3>
<p>
Есть два общепринятых способа запускать модульные приложения: запуск
напрямую с помощью <tt>run!</tt>:
</p>
<pre>
  # my_app.rb
  require 'sinatra/base'

  class MyApp &lt; Sinatra::Base
    # ... здесь код приложения ...

    # запускаем сервер, если исполняется текущий файл
    run! if app_file == $0
  end
</pre>
<p>
И запускаем с помощью:
</p>
<pre>
  ruby my_app.rb
</pre>
<p>
Или с помощью конфигурационного файла <tt>config.ru</tt>, который позволяет
использовать любой Rack-совместимый сервер приложений.
</p>
<pre>
  # config.ru
  require 'my_app'
  run MyApp
</pre>
<p>
Запускаем:
</p>
<pre>
  rackup -p 4567
</pre>
<a name='%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20&%238220;%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85&%238221;%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%81%20config.ru'></a>
<h3>Запуск &#8220;классических&#8221; приложений с config.ru</h3>
<p>
Файл приложения:
</p>
<pre>
  # app.rb
  require 'sinatra'

  get '/' do
    'Hello world!'
  end
</pre>
<p>
И соответствующий <tt>config.ru</tt>:
</p>
<pre>
  require 'app'
  run Sinatra::Application
</pre>
<a name='%D0%9A%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20config.ru?'></a>
<h3>Когда использовать config.ru?</h3>
<p>
Вот несколько причин, по которым вы, возможно, захотите использовать
<tt>config.ru</tt>:
</p>
<ul>
<li><p>
вы хотите разворачивать свое приложение на различных Rack-совместимых
серверах (Passenger, Unicorn, Heroku, &#8230;).
</p>
</li>
<li><p>
вы хотите использовать более одного сабкласса <tt>Sinatra::Base</tt>.
</p>
</li>
<li><p>
вы хотите использовать Sinatra только в качестве &#8220;прослойки&#8221;
Rack.
</p>
</li>
</ul>
<p>
<b>Совсем необязательно переходить на использование <tt>config.ru</tt> лишь
потому, что вы стали использовать модульный стиль приложения. И
необязательно использовать модульный стиль, чтобы запускать приложение с
помощью <tt>config.ru</tt>.</b>
</p>
<a name='%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20Sinatra%20%D0%B2%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5%20&%238220;%D0%BF%D1%80%D0%BE%D1%81%D0%BB%D0%BE%D0%B9%D0%BA%D0%B8&%238220;'></a>
<h3>Использование Sinatra в качестве &#8220;прослойки&#8220;</h3>
<p>
Не только сама Sinatra может использовать &#8220;прослойки&#8221; Rack, но
и любое Sinatra приложение само может быть добавлено к любому Rack
эндпоинту в качестве &#8220;прослойки&#8221;. Этим эндпоинтом может быть
другое Sinatra приложение, или приложение, основанное на Rack
(Rails/Ramaze/Camping/&#8230;).
</p>
<pre>
  require 'sinatra/base'
  
  class LoginScreen &lt; Sinatra::Base
    enable :sessions
    
    get('/login') { haml :login }
    
    post('/login') do
      if params[:name] = 'admin' and params[:password] = 'admin'
        session['user_name'] = params[:name]
      else
        redirect '/login'
      end
    end
  end
  
  class MyApp &lt; Sinatra::Base
    # &quot;прослойка&quot; будет запущена перед фильтрами
    use LoginScreen
    
    before do
      unless session['user_name']
        halt &quot;Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;.&quot;
      end
    end
    
    get('/') { &quot;Hello #{session['user_name']}.&quot; }
  end
</pre>
<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D1%8F%D0%B7%D0%BA%D0%B0'></a>
<h2>Области видимости и привязка</h2>
<p>
Текущая область видимости определяет методы и переменные, доступные в
данный момент.
</p>
<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20/%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0'></a>
<h3>Область видимости приложения / класса</h3>
<p>
Любое Sinatra приложение соответствует сабклассу Sinatra::Base. Если вы 
используете DSL верхнего  уровня (<tt>require 'sinatra'</tt>), то этим
классом будет  Sinatra::Application, иначе это будет сабкласс, который вы
создали вручную. На уровне класса вам будут доступны такие методы, как
`get` или `before`, но вы не сможете иметь доступ к объектам `request` или
`session`, так как существует только единый класс приложения для всех
запросов.
</p>
<p>
Опции, созданные с помощью `set`, являются методами уровня класса:
</p>
<pre>
    class MyApp &lt; Sinatra::Base
      # Я в области видимости приложения!
      set :foo, 42
      foo # =&gt; 42
      
      get '/foo' do
        # Я больше не в области видимости приложения!
      end
    end
</pre>
<p>
У вас будет область видимости приложения внутри:
</p>
<ul>
<li><p>
Тела вашего класса приложения
</p>
</li>
<li><p>
Методов, определенных расширениями
</p>
</li>
<li><p>
Блока, переданного в `helpers`
</p>
</li>
<li><p>
Блоков, использованных как значения для `set`
</p>
</li>
</ul>
<p>
Вы можете получить доступ к объекту области видимости (классу приложения)
следующими способами:
</p>
<ul>
<li><p>
объект, переданный блокам конфигурации (<tt>configure { |c| ... }</tt>)
</p>
</li>
<li><p>
`settings` внутри области видимости запроса
</p>
</li>
</ul>
<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0/%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0'></a>
<h3>Область видимости запроса/экземпляра</h3>
<p>
Для каждого входящего запроса будет создан новый экземпляр вашего
приложения, и все блоки обработчика будут запущены в этом контексте. В этой
области видимости вам доступны `request` и `session` объекты, вызовы
методов рендеринга, такие как `erb` или `haml`. Вы можете получить доступ к
области видимости приложения из контекста запроса, используя помощник
`settings`:
</p>
<pre>
  class MyApp &lt; Sinatra::Base
    # Я в области видимости приложения!
    get '/define_route/:name' do
      # Область видимости запроса '/define_route/:name'
      @value = 42
      
      settings.get(&quot;/#{params[:name]}&quot;) do
        # Область видимости запроса &quot;/#{params[:name]}&quot;
        @value # =&gt; nil (другой запрос)
      end
      
      &quot;Route defined!&quot;
    end
  end
</pre>
<p>
У вас будет область видимости запроса внутри:
</p>
<ul>
<li><p>
get/head/post/put/delete/options блоков
</p>
</li>
<li><p>
before/after фильтрах
</p>
</li>
<li><p>
методах помощниках 
</p>
</li>
<li><p>
шаблонах/видах
</p>
</li>
</ul>
<a name='%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F'></a>
<h3>Область видимости делегирования</h3>
<p>
Область видимости делегирования просто перенаправляет методы в область
видимости класса. Однако, оно не полностью на 100% ведет себя как область
видимости класса, так как у вас нету привязки к классу: только методы, явно
помеченные для делегирования, будут доступны, а переменных/состояний
области видимости класса не будет (иначе говоря, у вас будет другой `self`
объект). Вы можете непосредственно добавить методы делегирования, используя
<tt>Sinatra::Delegator.delegate :method_name</tt>.
</p>
<p>
У вас будет контекст делегирования внутри:
</p>
<ul>
<li><p>
Привязки верхнего уровня, если вы сделали <tt>require
&quot;sinatra&quot;</tt>
</p>
</li>
<li><p>
Объекта, расширенного с помощью примеси `Sinatra::Delegator`
</p>
</li>
</ul>
<p>
Посмотрите сами в код: тут <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
примесь</a> будет <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">включена
в глобальное пространство имен</a>.
</p>
<a name='%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0'></a>
<h2>Командная строка</h2>
<p>
Sinatra приложения могут быть запущены напрямую:
</p>
<pre>
  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
</pre>
<p>
Опции включают:
</p>
<pre>
  -h # помощь
  -p # настроить порт (по умолчанию 4567)
  -o # настроить хост (по умолчанию 0.0.0.0)
  -e # настроить окружение, режим (по умолчанию development)
  -s # настроить rack сервер/обработчик (по умолчанию thin)
  -x # включить мьютекс (по умолчанию выключен)
</pre>
<a name='%D0%9D%D0%B0%20%D0%BE%D1%81%D1%82%D1%80%D0%B8%D0%B5'></a>
<h2>На острие</h2>
<p>
Если вы хотите использовать самый последний код Sinatra, не бойтесь
запускать свое приложение вместе с master бранчем Sinatra, он весьма
стабилен.
</p>
<p>
Мы также время от времени выпускаем предварительные версии, так что вы
можете делать так:
</p>
<pre>
  gem install sinatra --pre
</pre>
<p>
Чтобы воспользоваться некоторыми самыми последними возможностям.
</p>
<a name='%D0%A1%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20Bundler'></a>
<h3>С помощью Bundler</h3>
<p>
Если вы хотите запускать свое приложение с последней версией Sinatra, то
рекомендуем использовать <a href="http://gembundler.com/">Bundler</a>.
</p>
<p>
Сначала установите Bundler, если у вас его еще нет:
</p>
<pre>
  gem install bundler
</pre>
<p>
Затем создайте файл <tt>Gemfile</tt> в директории вашего проекта:
</p>
<pre>
  source :rubygems
  gem 'sinatra', :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

  # другие зависимости
  gem 'haml'                    # например, если используете haml
  gem 'activerecord', '~&gt; 3.0'  # может быть, вам нужен и ActiveRecord 3.x
</pre>
<p>
Обратите внимание, вам нужно будет указывать все зависимости вашего
приложения в этом файле. Однако, непосредственные зависимости Sinatra (Rack
и Tilt) Bundler автоматически скачает и добавит.
</p>
<p>
Теперь вы можете запускать свое приложение примерно так:
</p>
<pre>
  bundle exec ruby myapp.rb
</pre>
<a name='%D0%92%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E'></a>
<h3>Вручную</h3>
<p>
Создайте локальный клон репозитория и запускайте свое приложение с
<tt>sinatra/lib</tt> директорией в <tt>LOAD_PATH</tt>:
</p>
<pre>
  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb
</pre>
<p>
Чтобы обновить исходники Sinatra:
</p>
<pre>
  cd myapp/sinatra
  git pull
</pre>
<a name='%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE'></a>
<h3>Установка глобально</h3>
<p>
Вы можете самостоятельно собрать gem:
</p>
<pre>
  git clone git://github.com/sinatra/sinatra.git
  cd sinatra
  rake sinatra.gemspec
  rake install
</pre>
<p>
Если вы устанавливаете пакеты (gem) от пользователя root, то вашим
последним шагом должна быть команда
</p>
<pre>
  sudo rake install
</pre>
<a name='%D0%94%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B5%D0%B5%20%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5'></a>
<h2>Дальнейшее чтение</h2>
<ul>
<li><p>
<a href="http://www.sinatrarb.com/">Вебсайт проекта</a> - Дополнительная
документация, новости и ссылки на другие ресурсы.
</p>
</li>
<li><p>
<a href="http://www.sinatrarb.com/contributing">Участие</a> - Нашли баг?
Нужна помощь?	Написали патч?
</p>
</li>
<li><p>
<a href="http://github.com/sinatra/sinatra/issues">Слежение за
проблемами</a>
</p>
</li>
<li><p>
<a href="http://twitter.com/sinatra">Twitter</a>
</p>
</li>
<li><p>
<a href="http://groups.google.com/group/sinatrarb/topics">Лист рассылки</a>
</p>
</li>
<li><p>
<a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> on <a
href="http://freenode.net">freenode.net</a> 
</p>
</li>
</ul>